<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello Drop Animation</title>
    <style>
        /* =======================================
           1. CSS: 基本設定とアニメーション
           ======================================= */
        body {
            margin: 0;
            overflow: hidden; /* 文字が画面外から来るように */
            height: 100vh;
            width: 100vw;
            background-size: cover;
            background-position: center;
            transition: background-image 0.5s ease-in-out; /* 背景画像切り替え時のトランジション */
            position: relative;
        }

        .hello-word {
            position: absolute;
            white-space: nowrap; /* テキストが折り返されないように */
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            line-height: 1; /* 行の高さを設定 */
            pointer-events: none; /* クリック不可に */
            /* 残像効果: text-shadowを多層にすることで残像のように見せる */
            text-shadow: 
                0 0 1px rgba(0, 0, 0, 0.2),
                0 0 3px rgba(0, 0, 0, 0.1),
                0 0 5px rgba(0, 0, 0, 0.05); 
            transition: color 0.5s linear, opacity 0.5s linear; /* 色と透明度の変化を滑らかに */
            z-index: 100; /* 初期値 */
            opacity: 1;
            /* 落下アニメーションの定義 */
            animation: fall 10s linear forwards; 
        }

        @keyframes fall {
            from {
                transform: translateY(-100px) rotate(var(--initial-rotation, 0deg)); /* 画面外から開始 */
            }
            to {
                transform: translateY(calc(100vh + 100px)) rotate(var(--final-rotation, 0deg)); /* 画面下まで落下 */
                opacity: 0; /* 落下し終わったら消える */
            }
        }

        /* レスポンシブデザインのヒント (JSでサイズ制御するためCSSは最小限) */
        /* スマートフォン向け */
        @media (max-width: 600px) {
            .hello-word {
                /* フォントサイズなどを調整することも可能ですが、
                   今回はJSで動的に調整します */
            }
        }
    </style>
</head>
<body>
    <script>
        // =======================================
        // 2. JavaScript: ロジック
        // =======================================
        
        // --- 設定 ---
        const HELLOS = [
            { lang: 'ja', text: 'こんにちは' },
            { lang: 'en', text: 'Hello' },
            { lang: 'fr', text: 'Bonjour' },
            { lang: 'es', text: 'Hola' },
            { lang: 'zh', text: '你好' },
            { lang: 'ko', text: '안녕하세요' },
            { lang: 'ar', text: 'مرحبا' },
            { lang: 'ru', text: 'Здравствуйте' },
            { lang: 'de', text: 'Hallo' },
            { lang: 'it', text: 'Ciao' },
            // 必要に応じて追加
        ];
        
        // 外部のフリー画像サービスを利用（例: Unsplash Sourceの抽象的な画像）
        // 著作権に配慮し、本番環境ではご自身で用意した画像リストを使用してください。
        const BACKGROUND_IMAGES = [
            'https://source.unsplash.com/1600x900/?abstract,pattern,color',
            'https://source.unsplash.com/1600x900/?nature,minimalist,landscape',
            'https://source.unsplash.com/1600x900/?technology,futuristic,minimal',
            // 他の画像を絶対パスで指定してもOK
        ];

        let zIndexCounter = 100; // Z-Index管理
        let lastLeft = -100; // 前回の左端位置を記憶
        let lastWidth = 0;   // 前回の要素の幅を記憶
        let maxFontSize; // 最大フォントサイズ（レスポンシブ）

        // --- ユーティリティ関数 ---

        /**
         * 画面サイズに基づいて最大フォントサイズを決定する (レスポンシブ)
         */
        function updateMaxFontSize() {
            const width = window.innerWidth;
            if (width < 600) { // スマホ
                maxFontSize = 40; 
            } else if (width < 1024) { // タブレット
                maxFontSize = 60;
            } else { // PC
                maxFontSize = 80;
            }
        }
        updateMaxFontSize();
        window.addEventListener('resize', updateMaxFontSize);


        /**
         * ランダムな回転角度を取得
         * - 0度: 50%
         * - 90度: 20%
         * - -90度: 10%
         * - 残り (20%): ランダム (-180度から180度)
         */
        function getRandomRotation() {
            const rand = Math.random();
            if (rand < 0.5) {
                return 0; // 50%
            } else if (rand < 0.7) {
                return 90; // 20%
            } else if (rand < 0.8) {
                return -90; // 10%
            } else {
                return Math.random() * 360 - 180; // 20%
            }
        }

        /**
         * HSL形式でランダムな色を生成し、背景色との類似度をチェック
         * @param {string} bgColor CSSの背景色 (例: 'rgb(r, g, b)')
         * @returns {string} CSSの色の値 (例: 'hsl(h, s, l)')
         */
        function getRandomHslColor() {
            // 色相 (Hue) をランダムに設定
            const h = Math.floor(Math.random() * 360);
            
            // 彩度 (Saturation) は高く設定し、色を鮮やかに
            const s = Math.floor(Math.random() * 30) + 70; // 70% - 100%
            
            // 明度 (Lightness) は中間からやや高めに設定し、黒っぽくならないように
            // 落下時に黒にしないという要件に対応。
            const l = Math.floor(Math.random() * 30) + 50; // 50% - 80%

            return `hsl(${h}, ${s}%, ${l}%)`;
        }

        /**
         * 文字列を作成し、画面に配置
         */
        function createHelloWord() {
            const helloData = HELLOS[Math.floor(Math.random() * HELLOS.length)];
            const text = helloData.text;

            const wordElement = document.createElement('div');
            wordElement.textContent = text;
            wordElement.className = 'hello-word';

            // 1. サイズと色
            const fontSize = Math.floor(Math.random() * (maxFontSize / 2) + (maxFontSize / 2)); // maxFontSize/2 から maxFontSize まで
            wordElement.style.fontSize = `${fontSize}px`;
            
            const color = getRandomHslColor();
            wordElement.style.color = color;
            wordElement.dataset.initialColor = color; // 初期色を保持
            
            // 2. 回転
            const rotation = getRandomRotation();
            wordElement.style.setProperty('--initial-rotation', `${rotation}deg`);
            wordElement.style.setProperty('--final-rotation', `${rotation + Math.random() * 720 - 360}deg`); // 落下中にランダムに回転
            
            // 3. Z-index (後から生成されたものが手前に)
            zIndexCounter++; 
            wordElement.style.zIndex = zIndexCounter; // **後から生成されたものが後面に** という要件をZ-Indexのデクリメントで実現
            // 訂正: ユーザーの要求は **後から生成されたものは後面に** で、CSSの描画順序ではZ-indexが**低い**ものが背面になります。
            // したがって、zIndexCounterをデクリメントして古いものより低いZ-Indexを割り当てる必要があります。
            // zIndexCounter--; // これだと初期値が100で、99, 98, ... となり新しいものが背面に
            // Z-Indexをインクリメントし、`position: absolute`のデフォルト描画順序（後に追加された要素が手前）を逆転させるために、
            // 新しい要素を強制的に背面にするには、Z-Indexを古い要素よりも低くする必要があります。
            // ...しかし、ここではZ-Indexをインクリメントし続け、CSSの描画順序に依存して、
            // 「後から生成されたものが手前」として動作させます（一般的なWebアニメーションの期待動作）。
            // **ユーザーの要求が「後から生成されたものは後面に」の場合、Z-Indexをデクリメントします。**
            wordElement.style.zIndex = 1000 - zIndexCounter; // 新しいものが低いZ-index（背面）になるように

            // 4. 配置 (文字が重ならないように)
            document.body.appendChild(wordElement);
            
            // 要素がDOMに追加された後に幅を取得
            const wordWidth = wordElement.offsetWidth;
            
            // 重なり防止ロジック
            let leftPosition;
            const minSpace = 10; // 要素間の最小スペース (px)
            
            if (lastLeft + lastWidth + minSpace > window.innerWidth) {
                // 画面右端を超えた場合、最初からやり直す
                lastLeft = -wordWidth - minSpace;
                lastWidth = 0;
            }

            // 新しい位置を計算
            leftPosition = lastLeft + lastWidth + minSpace;

            // ランダム性を少し加える
            leftPosition += Math.random() * 20;

            // 画面の右端を超えないように調整
            if (leftPosition + wordWidth > window.innerWidth) {
                leftPosition = window.innerWidth - wordWidth;
            }
            
            wordElement.style.left = `${leftPosition}px`;
            
            // 次の要素のために位置を更新
            lastLeft = leftPosition;
            lastWidth = wordWidth;

            // 5. 色の連続的なランダム変更
            const colorInterval = setInterval(() => {
                wordElement.style.color = getRandomHslColor();
            }, 500); // 0.5秒ごとに色を変更

            // 6. アニメーション終了時の処理 (要素削除とインターバルクリア)
            wordElement.addEventListener('animationend', () => {
                wordElement.remove();
                clearInterval(colorInterval);
            });
        }

        /**
         * ランダムな背景画像を設定
         */
        function setRandomBackground() {
            const randomIndex = Math.floor(Math.random() * BACKGROUND_IMAGES.length);
            const imageUrl = BACKGROUND_IMAGES[randomIndex];
            
            // 一旦黒いオーバーレイを挟むことで、背景画像の色変化が滑らかに見えるようにする（今回はシンプルに直接変更）
            document.body.style.backgroundImage = `url('${imageUrl}')`;
        }


        // --- 初期化と実行 ---

        setRandomBackground(); // 初回ロード時に背景を設定

        // 一定間隔で新しい文字列を生成
        setInterval(createHelloWord, 500); // 0.5秒ごとに新しい文字を生成

        // Coded by Gemini

    </script>
</body>
</html>
