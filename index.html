<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello Drop Animation</title>
    <style>
        /* =======================================
           1. CSS: 基本設定とアニメーション
           ======================================= */
        body {
            margin: 0;
            overflow: hidden; /* 文字が画面外から来るように */
            height: 100vh;
            width: 100vw;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: background-image 0.5s ease-in-out; 
            position: relative;
        }

        .hello-word {
            position: absolute;
            white-space: nowrap; /* テキストが折り返されないように */
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            line-height: 1; 
            pointer-events: none; 
            
            /* 残像効果: text-shadowを多層にして残像のように見せる */
            text-shadow: 
                0 0 1px rgba(0, 0, 0, 0.2),
                0 0 3px rgba(0, 0, 0, 0.1),
                0 0 5px rgba(0, 0, 0, 0.05),
                0 0 10px rgba(0, 0, 0, 0.03); 
                
            transition: color 0.5s linear, opacity 0.5s linear;
            z-index: 1000; /* 初期値（JSで動的に変更されます） */
            opacity: 1;
            
            /* 落下アニメーションの定義 */
            animation: fall var(--duration) linear forwards; /* 落下時間をJSから取得 */
        }

        @keyframes fall {
            from {
                /* transform: translateY(-100px) rotate(var(--initial-rotation, 0deg)); */
                /* 落下開始時は画面外の上部に配置 */
                transform: translate(0, -100px) rotate(var(--initial-rotation, 0deg));
            }
            to {
                /* 画面下まで落下し、さらにランダムな回転を伴う */
                transform: translate(0, calc(100vh + 100px)) rotate(var(--final-rotation, 0deg)); 
                opacity: 0; /* 落下し終わったら消える */
            }
        }
    </style>
</head>
<body>
    <script>
        // =======================================
        // 2. JavaScript: ロジック
        // =======================================
        
        // --- 設定 ---
        const HELLOS = [
            { lang: 'ja', text: 'こんにちは' },
            { lang: 'en', text: 'Hello' },
            { lang: 'fr', text: 'Bonjour' },
            { lang: 'es', text: 'Hola' },
            { lang: 'zh', text: '你好' },
            { lang: 'ko', text: '안녕하세요' },
            { lang: 'ar', text: 'مرحبا' },
            { lang: 'ru', text: 'Здравствуйте' },
            { lang: 'de', text: 'Hallo' },
            { lang: 'it', text: 'Ciao' },
            { lang: 'pt', text: 'Olá' },
        ];
        
        // **ユーザー指定の背景画像URL**
        const BACKGROUND_IMAGE_URL = 'https://picsum.photos/1920/1080?random';

        let zIndexCounter = 0; // Z-Index管理 (新しいものが背面になるようにデクリメント式で使う)
        let columnPositions = []; // 各列の次に来るべき左端の位置を記憶
        let maxColumns = 10; // 画面幅に応じて調整する列の最大数
        let maxFontSize; // 最大フォントサイズ（レスポンシブ）
        let minSpace = 5; // 要素間の最小スペース (px)


        // --- ユーティリティ関数 ---

        /**
         * 画面サイズに基づいて最大フォントサイズと列数を決定する (レスポンシブ)
         */
        function updateLayoutSettings() {
            const width = window.innerWidth;
            if (width < 600) { // スマホ
                maxFontSize = 30; 
                maxColumns = 5;
            } else if (width < 1024) { // タブレット
                maxFontSize = 50;
                maxColumns = 7;
            } else { // PC
                maxFontSize = 80;
                maxColumns = 10;
            }
            // 列位置配列をリセット/初期化
            columnPositions = Array(maxColumns).fill(0);
        }
        updateLayoutSettings();
        window.addEventListener('resize', updateLayoutSettings);


        /**
         * ランダムな回転角度を取得
         * - 0度: 50%
         * - 90度: 20%
         * - -90度: 10%
         * - 残り (20%): ランダム (-180度から180度)
         */
        function getRandomRotation() {
            const rand = Math.random();
            if (rand < 0.5) {
                return 0; // 50%
            } else if (rand < 0.7) {
                return 90; // 20%
            } else if (rand < 0.8) {
                return -90; // 10%
            } else {
                return Math.random() * 360 - 180; // 20%
            }
        }

        /**
         * HSL形式でランダムな色を生成（落下時に黒にならないように明度を調整）
         */
        function getRandomHslColor() {
            const h = Math.floor(Math.random() * 360);
            const s = Math.floor(Math.random() * 30) + 70; // 70% - 100%
            const l = Math.floor(Math.random() * 30) + 50; // 50% - 80% (黒を回避)

            return `hsl(${h}, ${s}%, ${l}%)`;
        }

        /**
         * 文字列を作成し、画面に配置
         */
        function createHelloWord() {
            const helloData = HELLOS[Math.floor(Math.random() * HELLOS.length)];
            const text = helloData.text;

            const wordElement = document.createElement('div');
            wordElement.textContent = text;
            wordElement.className = 'hello-word';

            // 1. サイズと色
            const fontSize = Math.floor(Math.random() * (maxFontSize / 2) + (maxFontSize / 2));
            wordElement.style.fontSize = `${fontSize}px`;
            wordElement.style.color = getRandomHslColor();
            
            // 2. 回転
            const initialRotation = getRandomRotation();
            wordElement.style.setProperty('--initial-rotation', `${initialRotation}deg`);
            wordElement.style.setProperty('--final-rotation', `${initialRotation + Math.random() * 720 - 360}deg`);
            
            // 3. 落下時間
            // 落下時間をランダムに設定（速すぎず遅すぎない範囲で）
            const duration = Math.floor(Math.random() * 5) + 7; // 7秒から12秒
            wordElement.style.setProperty('--duration', `${duration}s`);
            
            // 4. Z-index (後から生成されたものは後面に)
            // zIndexCounterをインクリメントし、1000から引くことで、後から生成された要素ほど低いZ-index（背面）になる。
            zIndexCounter++;
            wordElement.style.zIndex = 1000 - zIndexCounter;

            // 5. 配置 (文字が重ならないように)
            document.body.appendChild(wordElement);
            
            const wordWidth = wordElement.offsetWidth;
            const screenWidth = window.innerWidth;
            
            // 重なり防止ロジック: 複数の列を管理
            let bestColumn = -1;
            let bestX = -1;
            
            for (let i = 0; i < maxColumns; i++) {
                // 列の開始位置を均等に計算
                const columnStart = (screenWidth / maxColumns) * i;
                
                // 列の現在の位置
                const currentX = Math.max(columnStart, columnPositions[i]);
                
                // 要素が画面内に収まるかチェック
                if (currentX + wordWidth + minSpace < screenWidth) {
                    bestColumn = i;
                    bestX = currentX;
                    break; 
                }
            }

            if (bestColumn !== -1) {
                // 最適な列に配置
                wordElement.style.left = `${bestX}px`;
                // 次の要素のために列の位置を更新
                columnPositions[bestColumn] = bestX + wordWidth + minSpace;
            } else {
                // 画面がいっぱいになった場合や、配置が難しかった場合はランダムな位置に配置
                // この要素は重なる可能性があるが、完全に停止することを避ける
                wordElement.style.left = `${Math.random() * (screenWidth - wordWidth)}px`;
            }

            // 6. 色の連続的なランダム変更
            const colorInterval = setInterval(() => {
                wordElement.style.color = getRandomHslColor();
            }, 500); // 0.5秒ごとに色を変更

            // 7. アニメーション終了時の処理 (要素削除とインターバルクリア)
            wordElement.addEventListener('animationend', () => {
                wordElement.remove();
                clearInterval(colorInterval);
            });
            
            // 8. 落下後、列の位置をリセットする処理
            // アニメーションが終了したら、その要素が占めていたであろう列のスペースを将来的に再利用可能にする
            setTimeout(() => {
                // ここでcolumnPositionsをリセットするのは複雑になるため、一定時間後にリセットする処理は省略
                // （代わりに、列位置を画面外に移動させることで再利用を促進）
                if (bestColumn !== -1) {
                   columnPositions[bestColumn] = -wordWidth - minSpace;
                }
            }, duration * 1000);
        }

        /**
         * ランダムな背景画像を設定
         */
        function setRandomBackground() {
            // PicsumのURLはアクセスごとにランダムな画像を提供します。
            // キャッシュを防ぎ、確実に新しい画像を取得するために、URLに時刻スタンプを追加します。
            const imageUrl = `${BACKGROUND_IMAGE_URL}&t=${new Date().getTime()}`;
            document.body.style.backgroundImage = `url('${imageUrl}')`;
        }


        // --- 初期化と実行 ---

        setRandomBackground(); // 初回ロード時に背景を設定

        // 一定間隔で新しい文字列を生成
        setInterval(createHelloWord, 500); // 0.5秒ごとに新しい文字を生成

        // Coded by Gemini

    </script>
</body>
</html>
